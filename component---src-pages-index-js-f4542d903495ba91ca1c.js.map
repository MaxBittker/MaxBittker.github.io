{"version":3,"sources":["webpack:///./src/components/webgl.js","webpack:///./src/components/fragmentShader.js","webpack:///./src/components/loom.js","webpack:///./src/pages/index.js"],"names":["createReactClass","displayName","getInitialState","width","Math","min","window","innerHeight","innerWidth","height","ready","e","componentDidMount","_this","this","init","canvas","gl","getContext","state_","animationFrameRequest","bit","fb","time0","Date","textures","videoTexture","mouse","x","y","onmousemove","throttle","event","r","target","getBoundingClientRect","clientX","left","right","clientY","bottom","top","loadProgram","state","setState","WIDTH","HEIGHT","compileShader","source","shaderType","shader","createShader","shaderSource","getShaderParameter","COMPILE_STATUS","console","log","Error","getShaderInfoLog","vs","VERTEX_SHADER","fs","FRAGMENT_SHADER","program","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","useProgram","bindBuffer","ARRAY_BUFFER","createBuffer","bufferData","Float32Array","STATIC_DRAW","aPosition","getAttribLocation","enableVertexAttribArray","vertexAttribPointer","FLOAT","createTarget","texture","createTexture","framebuffer","createFramebuffer","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","COLOR_ATTACHMENT0","image","img","Image","src","push","black","time","getUniformLocation","resolution","backBuffer","channel1","channel2","draw","requestAnimationFrame","animate","uniform1f","getTime","uniform2f","uniform1i","activeTexture","TEXTURE0","clear","COLOR_BUFFER_BIT","drawArrays","TRIANGLE_STRIP","componentDidUpdate","cancelAnimationFrame","componentWillUnmount","render","_this2","react_default","a","createElement","ref","className","style","position","marginLeft","zIndex","Loom","mounted","rows","Array","from","keys","map","w","raw","random","sum","reduce","b","ceil","id","patternUnits","d","row","row_sums","values","acc","sums","forEach","v","c","key","fill","stroke","Raven","config","release","enviroment","install","Index","loom","React","Component"],"mappings":"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","file":"component---src-pages-index-js-f4542d903495ba91ca1c.js","sourcesContent":["import React from \"react\";\nimport createReactClass from \"create-react-class\";\n\nimport fShaderSource from \"./fragmentShader.js\";\nimport { throttle } from \"lodash\";\n\nconst vsSource = `\nattribute vec3 aPosition;\nvarying vec2 uvN;\nvoid main()\n{\n  gl_Position = vec4(aPosition, 1.0);\n  uvN = aPosition.xy;\n}`;\n//\n// if(typeof window == 'undefined'){//SSR hack\n//   debugger;\n//   var window = {innerWidth:100,innerHeight:100};\n// }\n\nexport default createReactClass({\n  getInitialState() {\n    try {\n      return {\n        width: Math.min(window.innerHeight, window.innerWidth),\n        height: window.innerHeight - 50,\n        ready: true\n      };\n    } catch (e) {\n      return {\n        width: 100,\n        height: 100,\n        ready: false\n      };\n    }\n  },\n\n  componentDidMount() {\n    let init = () => {\n      let canvas = this.canvas;\n      this.gl = canvas.getContext(\"webgl\");\n\n      this.state_ = {\n        animationFrameRequest: null,\n        bit: 0,\n        fb: [null, null],\n        time0: new Date() / 1000,\n        textures: [],\n        videoTexture: null,\n        mouse: { x: 0, y: 0 }\n      };\n\n      let setMouse = event => {\n        var r = event.target.getBoundingClientRect();\n        this.state_.mouse.x = (event.clientX - r.left) / (r.right - r.left);\n        this.state_.mouse.y = (event.clientY - r.bottom) / (r.top - r.bottom);\n      };\n      canvas.onmousemove = throttle(setMouse, 200);\n      /* canvas.onmousedown = (event) => setMouse(event, 1); */\n      /* canvas.onmouseup = (event) => setMouse(event, 0); */\n      this.loadProgram();\n    };\n\n    if (this.state.ready) {\n      init();\n    } else {\n      this.setState(\n        {\n          width: Math.min(window.innerHeight, window.innerWidth),\n          height: window.innerHeight,\n          ready: true\n        },\n        init\n      );\n    }\n  },\n  loadProgram() {\n    let gl = this.gl;\n    let state = this.state_;\n    let WIDTH = this.state.width / 2;\n    let HEIGHT = this.state.height / 2;\n\n    // compileShader :: (gl, source, shaderType) -> Shader\n    // throws Error on compilation error\n\n    function compileShader(gl, source, shaderType) {\n      let shader = gl.createShader(shaderType);\n\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n\n      let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n      if (!success) {\n        console.log(source);\n        throw Error(\"could not compile shader:\" + gl.getShaderInfoLog(shader));\n      }\n\n      return shader;\n    }\n\n    let vs = compileShader(gl, vsSource, gl.VERTEX_SHADER);\n    let fs = compileShader(gl, fShaderSource, gl.FRAGMENT_SHADER);\n\n    let program = gl.createProgram();\n\n    gl.attachShader(program, vs);\n    gl.attachShader(program, fs);\n\n    gl.linkProgram(program);\n\n    let success = gl.getProgramParameter(program, gl.LINK_STATUS);\n    if (!success) {\n      throw Error(\"program failed to link:\" + gl.getProgramInfoLog(program));\n    }\n    gl.useProgram(program);\n\n    // Create a square as a strip of two triangles.\n    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array([-1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]),\n      gl.STATIC_DRAW\n    );\n\n    // Assign attribute aPosition to each of the square's vertices.\n    gl.aPosition = gl.getAttribLocation(program, \"aPosition\");\n    gl.enableVertexAttribArray(gl.aPosition);\n    gl.vertexAttribPointer(gl.aPosition, 3, gl.FLOAT, false, 0, 0);\n\n    // backBuffer stuff\n    let createTarget = () => {\n      let target = {\n        texture: gl.createTexture(),\n        framebuffer: gl.createFramebuffer()\n      };\n      // set up framebuffer\n      gl.bindTexture(gl.TEXTURE_2D, target.texture);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        WIDTH,\n        HEIGHT,\n        0,\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        null\n      );\n\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n      gl.bindFramebuffer(gl.FRAMEBUFFER, target.framebuffer);\n      gl.framebufferTexture2D(\n        gl.FRAMEBUFFER,\n        gl.COLOR_ATTACHMENT0,\n        gl.TEXTURE_2D,\n        target.texture,\n        0\n      );\n\n      // clean up\n      gl.bindTexture(gl.TEXTURE_2D, null);\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n      return target;\n    };\n\n    state.fb[0] = createTarget();\n    state.fb[1] = createTarget();\n\n    //fixme: clean up\n    function createTexture(image) {\n      var texture = gl.createTexture();\n      gl.bindTexture(gl.TEXTURE_2D, texture);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n      gl.texImage2D(\n        gl.TEXTURE_2D,\n        0,\n        gl.RGBA,\n        gl.RGBA,\n        gl.UNSIGNED_BYTE,\n        image\n      );\n      state.textures.push(texture);\n    }\n\n    let img = new Image();\n    img.src =\n      \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFQAAABpAgMAAADZ4ewhAAAADFBMVEVlLWcjHyD///9aukdNbQb8AAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfgBBsTBjDG601/AAAAbUlEQVRIx2MIxQYYBoVo2Cp0MHXQiC5FcWvUIBJd//9q6P+/ofFAapCJDt4wWxpa/x/s3v//B53o4A2zwSo6WEuNQVvSQgEad1CIMmK41mFwiILprFXgRAilYOE78KKgnLBqJYwKHUSigzMHAADhlJM2vqJTOQAAAABJRU5ErkJggg==\";\n    createTexture(img);\n\n    let black = new Image();\n    black.src =\n      \"data:image/gif;base64,R0lGODlhAQABAIAAAAUEBAAAACwAAAAAAQABAAACAkQBADs=\";\n\n    state.videoTexture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, state.videoTexture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, black);\n\n    // remember the address within the fragment shader of each of my uniforms variables\n\n    gl.time = gl.getUniformLocation(program, \"time\");\n    gl.mouse = gl.getUniformLocation(program, \"mouse\");\n    gl.resolution = gl.getUniformLocation(program, \"resolution\");\n    gl.backBuffer = gl.getUniformLocation(program, \"backBuffer\");\n\n    gl.channel1 = gl.getUniformLocation(program, \"channel1\");\n    gl.channel2 = gl.getUniformLocation(program, \"channel2\");\n\n    this.draw();\n\n    if (state.animationFrameRequest === null) {\n      //INVARIANT: afr is non-null if we are animating.\n      state.animationFrameRequest = requestAnimationFrame(this.animate);\n    }\n  },\n\n  draw() {\n    let gl = this.gl;\n    let state = this.state_;\n\n    let WIDTH = this.state.width / 2;\n    let HEIGHT = this.state.height / 2;\n\n    gl.uniform1f(gl.time, new Date().getTime() / 1000 - state.time0);\n\n    gl.uniform2f(gl.mouse, state.mouse.x, state.mouse.y);\n    gl.uniform2f(gl.resolution, WIDTH, HEIGHT);\n    gl.uniform1i(gl.channel1, 1);\n    gl.activeTexture(gl.TEXTURE0 + 1);\n    gl.bindTexture(gl.TEXTURE_2D, state.textures[0]);\n\n    gl.uniform1i(gl.channel2, 2);\n    gl.activeTexture(gl.TEXTURE0 + 2);\n    gl.bindTexture(gl.TEXTURE_2D, state.videoTexture);\n\n    gl.uniform1i(gl.backBuffer, 0); // Do I need to check for null?\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, state.fb[state.bit].texture);\n    state.bit = (state.bit + 1) % 2;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, state.fb[state.bit].framebuffer);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, state.fb[state.bit].texture);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n  },\n  animate() {\n    this.draw();\n    this.state_.animationFrameRequest = requestAnimationFrame(this.animate);\n  },\n  componentDidUpdate() {\n    if (this.state.ready) {\n      cancelAnimationFrame(this.state_.animationFrameRequest);\n      this.state_.animationFrameRequest = null;\n      this.loadProgram();\n    }\n  },\n  componentWillUnmount() {\n    cancelAnimationFrame(this.state_.animationFrameRequest);\n  },\n  render() {\n    return (\n      <canvas\n        ref={ref => (this.canvas = ref)}\n        className={\"program\"}\n        style={{\n          position: \"absolute\",\n          left: \"50%\",\n          marginLeft: -(this.state.width / 2) + \"px\",\n          top: 50,\n          bottom: 0,\n          height: this.state.height + \"px\",\n          width: this.state.width + \"px\",\n          // maxWidth:'100%',\n          // maxHeight: \"60vh\",\n          // maxHeight: 'calc(100vh - 185px)',\n          zIndex: -1\n        }}\n        width={this.state.width / 2}\n        height={this.state.height / 2}\n      />\n    );\n  }\n});\n","const fShaderSource = `\nprecision highp float;\nconst float pi = 3.141592653589793238462643383;\nuniform float time;\nuniform vec2 mouse;\nuniform vec2 resolution;\nuniform sampler2D backBuffer;\nuniform sampler2D channel1;\nuniform sampler2D channel2;\nvarying vec2 uvN;\n\nfloat PI = 3.14159;\nfloat PI2 = 6.28318;\n\nvec3 black = vec3(0.0);\nvec3 white = vec3(1.0);\nvec3 red = vec3(0.86,0.22,0.27);\nvec3 orange = vec3(0.92,0.49,0.07);\nvec3 yellow = vec3(0.91,0.89,0.26);\nvec3 green = vec3(0.0,0.71,0.31);\nvec3 blue = vec3(0.05,0.35,0.65);\nvec3 purple = vec3(0.38,0.09,0.64);\nvec3 pink = vec3(.9,0.758,0.798);\nvec3 lime = vec3(0.361,0.969,0.282);\nvec3 teal = vec3(0.396,0.878,0.878);\nvec3 magenta = vec3(1.0, 0.189, 0.745);\nvec3 brown = vec3(0.96, 0.474, 0.227);\n\nvec2 mod289(vec2 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\nvec3 mod289(vec3 x) { return x - floor(x * (1.0/289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nconst mat2 myt = mat2(.12121212,.13131313,-.13131313,.12121212);\nconst vec2 mys = vec2(1e4, 1e6);\nvec2 rhash(vec2 uv) {\n    uv *= myt;\n    uv *= mys;\n    return  fract(fract(uv/mys)*uv);\n}\nvec3 hash( vec3 p ){\n    return fract(sin(vec3( dot(p,vec3(1.0,57.0,113.0)),\n                           dot(p,vec3(57.0,113.0,1.0)),\n                           dot(p,vec3(113.0,1.0,57.0))))*43758.5453);\n\n}\n\nfloat rand(const in float n){return fract(sin(n) * 1e4);}\nfloat rand(const in vec2 n) { return fract(1e4 * sin(17.0 * n.x + n.y * 0.1) * (0.1 + abs(sin(n.y * 13.0 + n.x))));\n}\n\nfloat noise(float x) {\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(rand(i), rand(i + 1.0), u);\n}\n\nfloat noise(vec2 x) {\n    vec2 i = floor(x);\n    vec2 f = fract(x);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(1.0, 0.0));\n    float c = rand(i + vec2(0.0, 1.0));\n    float d = rand(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( rand(n + dot(step, vec3(0, 0, 0))), rand(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( rand(n + dot(step, vec3(0, 1, 0))), rand(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( rand(n + dot(step, vec3(0, 0, 1))), rand(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( rand(n + dot(step, vec3(0, 1, 1))), rand(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nconst vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\nfloat snoise(vec2 v){\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 130.0 * dot(m, g);\n}\n\nconst vec2  CC = vec2(1.0/6.0, 1.0/3.0) ;\nconst vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\nfloat snoise(vec3 v){\n\n  vec3 i  = floor(v + dot(v, CC.yyy) );\n  vec3 x0 =   v - i + dot(i, CC.xxx) ;\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n  vec3 x1 = x0 - i1 + 1.0 * CC.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * CC.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * CC.xxx;\n  i = mod(i, 289.0 );\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\nfloat voronoi(const in vec2 point )\n{\n    vec2 p = floor( point );\n    vec2 f = fract( point );\n    float res = 0.0;\n    for( int j=-1; j<=1; j++ ) {\n        for( int i=-1; i<=1; i++ ) {\n            vec2 b = vec2( i, j );\n            vec2 r = vec2( b ) - f + rhash( p + b);\n            res += 1./pow(dot(r,r),8.);\n        }\n    }\n    return pow(1./res, 0.0625);\n}\n\nvec3 voronoi( const in vec3 x ) {\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n    float id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ ) {\n        for( int j=-1; j<=1; j++ ) {\n            for( int i=-1; i<=1; i++ ) {\n                vec3 b = vec3( float(i), float(j), float(k) );\n                vec3 r = vec3( b ) - f + hash( p + b );\n                float d = dot( r, r );\n\n                if( d < res.x ) {\n                    id = dot( p+b, vec3(1.0,57.0,113.0 ) );\n                    res = vec2( d, res.x );\n                }\n                else if( d < res.y ) {\n                    res.y = d;\n                }\n            }\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n//brownian\nfloat fbm(float x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    float shift = float(100);\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\nfloat fbm(vec2 x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = rot * x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\nfloat fbm(vec3 x, const in int it) {\n    float v = 0.0;\n    float a = 0.5;\n    vec3 shift = vec3(100);\n    // Rotate to reduce axial bias\n    float c = cos(0.3);\n    float s = sin(0.3);\n    mat3 rot = mat3(\n        c, 0.0, -s,\n        0.0, 1.0, 0.0,\n        s, 0.0, c\n    );\n    for (int i = 0; i < 32; ++i) {\n        if(i<it) {\n            v += a * noise(x);\n            x = rot * x * 2.0 + shift;\n            a *= 0.5;\n        }\n    }\n    return v;\n}\n\n//ridged multifractal\nfloat rmf(vec2 uv, const in int it) {\n    float l = 2.;\n    float r = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            uv = uv.yx * l;\n            float n = noise(uv);\n            n = abs(fract(n-.5)-.5);\n            n *= n * a;\n            a = clamp(0.,1., n*2.);\n            r += n*pow(f, -1.);\n            f *= l;\n        }\n    }\n    return r*2.;\n}\n\n//voronoi fbm\nfloat vfbm(const in vec2 uv, const in int it) {\n    float n = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            n += voronoi(uv*f)*a;\n            f *= 2.;\n            a *= .5;\n        }\n    }\n    return n;\n}\n\n//ridged multifractal\nfloat vrmf(vec2 uv, const in int it) {\n    float l = 2.;\n    float r = 0.;\n    float a = 0.5;\n    float f = 1.0;\n    for(int i = 0; i < 32; i++) {\n        if(i<it) {\n            uv = uv.yx * l;\n            float n = voronoi(uv);\n            n = abs(fract(n-.5)-.5);\n            n *= n * a;\n            a = clamp(0.,1., n*2.);\n            r += n*pow(f, -1.);\n            f *= l;\n        }\n    }\n    return r*2.;\n}\n\nconst vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec2 uv()\n{\n  return 0.5 * uvN  + 0.5;\n}\n\nfloat smin( float a, float b,float k)\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat xsdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat ysdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\nfloat zsdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xy)-t.x,p.z);\n  return length(q)-t.y;\n}\n\nfloat torusBall(vec3 p, vec2 t )\n{\n    return smin(\n        xsdTorus(p,t),\n        smin(\n            ysdTorus(p,t),\n            zsdTorus(p,t),\n            0.05),\n        0.05);\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nfloat sceneSDF(vec3 p){\n\n vec3 q = opRep(p,vec3(2.0) );\nfloat f = (sin(time*0.7)) * 25.;\nfloat a = 20.;\nvec3 offset = vec3(0.0,-0.2,sin(time)*0.1);\n// return zsdTorus(p, vec2(0.3,0.2));\nfloat d =  torusBall(p + offset, vec2(.4 -  abs(f)*0.005, abs(f)*0.005));\n\nd += (sin(f*p.x)*\n   sin(f*p.y)*\n   sin(f*p.z)*0.03);\n\n d -= fbm(p * 035.,4)*0.03;\n return d;\n}\n\nvec3 estimateNormal(vec3 p) {\n    float EPSILON = 0.001;\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\nvoid main () {\n    // float smaller = min(resolution.x,resolution.y)\n    float u = gl_FragCoord.x * 2.0 / resolution.x ;\n    float v = gl_FragCoord.y * 2.0 / resolution.y ;\n    vec2 st = vec2(u, v) - vec2(0.5);\n    vec2 stN = uv();\n\n    vec4 color = vec4(vec3(0.0,0.0,0.0), 0.0); // Sky color\n\n    vec3 up =      vec3(0, 1, 0);\n    vec3 right =   vec3(1, 0, 0);\n    vec3 forward = vec3(0 ,0, 1);\n\n\n    vec3 viewDir = rayDirection(45.0, vec2(1.0), st);\n     vec3 eye = normalize(vec3(\n      sin(time/4.+3.),// + mouse.x*4.,\n      sin(time/4.+2.),// + mouse.y*4.,\n      sin(time/4.+1.)\n      ))*2.5;\n\n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n\n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n\n\n    vec3 ro = eye;\n    vec3 rd = worldDir;\n    float t = 0.3;\n    const int maxSteps = 18;\n    int found = 0;\n    for(int i = 1; i < maxSteps; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = sceneSDF(p);\n\n        if(d < 0.01)\n        {\n        //   float fi = float(i) / float(maxSteps);\n          vec3 angle = estimateNormal(p);\n          vec3 oil = angle*0.1;\n        //   oil.r = fract(oil.r*2.0)*0.2;\n          oil.r += time*0.1;\n          oil.r = float( int(oil.r*9.) )/9. * 0.9,\n          oil.g = 0.2;//s\n          oil.b = 0.7;//v\n          oil = hsv2rgb(oil);\n          oil += dot(angle , up) * white*0.2;\n\n          color = vec4(oil, 1.0) ; // Sphere color\n\n          found = 1;\n          break;\n          \n        }\n        if(d>3.0){\n            break;\n        }\n\n        t += d;\n    }\n\n    if(length(color) > 1.55){//2.5* noise((st*5000.)+time)){\n        color = vec4(1.0);\n        // color = vec4(0.,0.,0.,1.);\n        \n    }else{\n        color = vec4(0.,0.,0.,0.);\n    }\n\n    float spread = 0.0075;\n    vec2 jitter = vec2(spread, 0.00) * noise(st * 100.*time);\n    jitter = jitter - vec2(spread*0.5,0.);\n    // jitter *=0.;\n    vec2 fall = vec2(0.0, spread*0.8) * (noise(st*1000.+time));\n    // vec2 suction = vec2(0.);\n    // vec2 push = (mouse / resolution) *0.5;\n    // vec2\n\n    vec2 sampleLoc = jitter + fall + stN;// + push;// + fall +\n    sampleLoc = vec2(0.,1./resolution.y) + stN;// + push;// + fall + suction;\n    //  sampleLoc = vec2(1./resolution.x,0.) + stN;// + push;// + fall + suction;\n\n    vec4 g = texture2D(backBuffer, sampleLoc).rgba;\n    if( length(g) < 0.1){\n      g = texture2D(backBuffer, sampleLoc).rgba;\n    }\n    // color +=\n    if(found==0 && st.y < 0.9){\n        // color = vec4(vec3(1.0),1.0);\n         color = g;\n      color*=0.999;\n    }\n    gl_FragColor = color;\n}`;\n\nexport default fShaderSource;\n","import React from \"react\";\nimport createReactClass from \"create-react-class\";\nimport { shuffle } from \"lodash\";\n\nfunction sums(values) {\n  let acc = 0;\n  let sums = [acc];\n  values.forEach(v => {\n    acc += v;\n    sums.push(acc);\n  });\n  return sums;\n}\n\nfunction make_row(w) {\n  let raw = Array.from(Array((1 + Math.random() * 8) | 0).keys()).map(() =>\n    Math.random()\n  );\n  let sum = raw.reduce((a, b) => a + b);\n  let vs = raw.map(r => 4 * Math.ceil(r * (w / 4 / sum)));\n\n  return vs;\n}\n\nlet rowHeight = 4 * 15;\n\nconst Loom = createReactClass({\n  getInitialState() {\n    return { mounted: false };\n  },\n  componentDidMount() {\n    this.setState({ mounted: true });\n  },\n  render() {\n    let height = 2000;\n    let width = 2000;\n    if (typeof window !== \"undefined\") {\n      width = window.innerWidth;\n      height = window.innerHeight;\n    }\n\n    if (!this.state.mounted) {\n      return <div />;\n    }\n    let rows = Array.from(Array((1 + height / rowHeight) | 0).keys()).map(() =>\n      make_row(width / 4)\n    );\n    // let rows = [[50, 50], [40, 30, 30], [10, 70, 20]];\n\n    return (\n      <svg className=\"loom\">\n        <pattern id=\"hatch\" patternUnits=\"userSpaceOnUse\" width=\"4\" height=\"4\">\n          <path\n            d=\"M-1,1 l2,-2\n           M0,4 l4,-4\n           M3,5 l2,-2\"\n          />\n        </pattern>\n        <pattern\n          id=\"left-hatch\"\n          patternUnits=\"userSpaceOnUse\"\n          width=\"4\"\n          height=\"4\"\n        >\n          <path\n            d=\"\n           M3,-1 l2,2\n           M-1,-1 l5,5\n           M-1,3 l2,2\"\n          />\n        </pattern>\n\n        {rows.map((row, r) => {\n          let row_sums = sums(row);\n          return row.map((w, c) => (\n            <rect\n              key={`${r}+${c}`}\n              x={row_sums[c] * 4}\n              y={r * rowHeight}\n              width={w * 4}\n              height={rowHeight}\n              fill={`url(#${Math.random() > 0.5 ? \"hatch\" : \"left-hatch\"})`}\n              style={{ stroke: \"none\" }}\n            />\n          ));\n        })}\n      </svg>\n    );\n  }\n});\nexport default Loom;\n","import React from \"react\";\nimport Raven from \"raven-js\";\nimport WebGL from \"../components/webgl.js\";\n\nimport \"./example.less\";\nimport Loom from \"../components/loom.js\";\n\nRaven.config(\"https://00f21757ccfe49a49742d4f9d7f1ab30@sentry.io/1234724\", {\n  release: \"2.0.0\",\n  enviroment: \"production\"\n}).install();\n\nexport default class Index extends React.Component {\n  render() {\n    return (\n      <div className=\"index\">\n        {/* <WebGL /> */}\n        <Loom />\n      </div>\n    );\n  }\n}\n"],"sourceRoot":""}